# Работа со строками

## Работа со строками в R

Для работы со строками можно использовать:

- базовый R
- пакет `stringr` (часть `tidyverse`)
- пакет `stringi` -- отдельный пакет, так что не забудьте его установить:

```{r}
#| eval: false

install.packages("stringi")
library(tidyverse)
library(stringi)
```

```{r}
#| include: false
library(tidyverse)
library(stringi)
```

Мы будем пользоваться в основном пакетами `stingr` и `stringi`, так как они в большинстве случаях удобнее. К счастью, функции этих пакетов легко отличить от остальных: функции пакета `stringr` всегда начинаются с `str_`, а функции пакета `stringi` --- c `stri_`.

Существует [cheat sheet по `stringr`](https://github.com/rstudio/cheatsheets/raw/master/strings.pdf).

## Как получить строку?

- следите за кавычками

```{r}
"the quick brown fox jumps over the lazy dog"
'the quick brown fox jumps over the lazy dog'
"the quick 'brown' fox jumps over the lazy dog"
'the quick "brown" fox jumps over the lazy dog'
"the quick \"brown\" fox jumps over the lazy dog"
```

Так как бэкслеш экранирует кавычку, если Вы хотите вставить бэкслеш в строку, придется поставить два бэкслеша.

```{r}
"the quick \"brown\" \\ fox jumps over the lazy dog"
```

Обычная печать RStudio может прятать происходящее, так что используйте функцию `str_view()`, чтобы посмотреть содержимое:

```{r}
str_view("the quick \"brown\" \\ fox jumps over the lazy dog")
```


- пустая строка

```{r}
""
''
character(3)
```

- преобразование

```{r}
typeof(4:7)
as.character(4:7)
```

- встроенные векторы

```{r}
letters
LETTERS
month.name
```

- cоздание рандомных строк

```{r}
set.seed(42)
stri_rand_strings(n = 10, length = 5:14)
```

- перемешивает символы внутри строки

```{r}
stri_rand_shuffle("любя, съешь щипцы, — вздохнёт мэр, — кайф жгуч")
stri_rand_shuffle(month.name)
```

- псевдорандомный текст^[Lorem ipsum --- классический текст-заполнитель на основе трактата Марка Туллия Цицерона "О пределах добра и зла". Его используют, чтобы посмотреть, как страница смотрится, когда заполнена текстом]

```{r}
stri_rand_lipsum(nparagraphs = 2)
```


## Соединение и разделение строк

Соединенить строки можно используя функцию `str_c()`, в которую, как и в функции `с()`, можно перечислять элементы через запятую:
```{r}
tibble(upper = rev(LETTERS), smaller = letters) |>  
  mutate(merge = str_c(upper, smaller))
```

Кроме того, если хочется, можно использовать особенный разделитель, указав его в аргументе `sep`:

```{r}
tibble(upper = rev(LETTERS), smaller = letters) |>  
  mutate(merge = str_c(upper, smaller, sep = "_"))
```

Иногда хочется составить длинные выражения, которые будут перемежаться значениями из переменных, это можно сделать при помощи функции `str_glue()`:

```{r}
tibble(month_name = month.name,
       month_abb = month.abb) |> 
  mutate(long_string = str_glue("The month {month_name} is abbreviated as {month_abb}"))
```

В фигурных скобках выступают имена переменных, которые уже есть в датасете. Если Вы хотите вставить в свое длинное выражение фигурные скобки, можно написать их два раза:

```{r}
tibble(month_name = month.name,
       month_abb = month.abb) |> 
  mutate(long_string = str_glue("The {{month}} {month_name} is abbreviated as {month_abb}"))
```

Для разделения строки на подстроки можно использовать функцию `separate()`. Это функция разносит разделенные элементы строки в соответствующие столбцы. У функции три обязательных аргумента: `col` --- колонка, которую следует разделить, `into` --- вектор названий новых столбцов, `sep` --- разделитель.

```{r}
tibble(upper = rev(LETTERS), smaller = letters) |>  
  mutate(merge = str_c(upper, smaller, sep = "_")) |>  
  separate(col = merge, into = c("column_1", "column_2"), sep = "_")
```

Кроме того, есть инструмент `str_split()`, который позволяет разбивать строки на подстроки, но возвращает *список*.

```{r}
str_split(month.name, "r")
```

## Количество символов

### Подсчет количества символов

```{r}
tibble(mn = month.name) |> 
  mutate(n_charactars = str_count(mn))
```

### Подгонка количества символов

Можно обрезать строки, используя функцию `str_trunc()`:

```{r}
tibble(mn = month.name) |> 
  mutate(mn_new = str_trunc(mn, 6))
```

Можно решить, с какой стороны обрезать, используя аргумент `side`:

```{r}
tibble(mn = month.name) |> 
  mutate(mn_new = str_trunc(mn, 6, side = "left"))
tibble(mn = month.name) |> 
  mutate(mn_new = str_trunc(mn, 6, side = "center"))
```

Можно заменить многоточие, используя аргумент `ellipsis`:

```{r}
tibble(mn = month.name) |> 
  mutate(mn_new = str_trunc(mn, 3, ellipsis = ""))
```

Можно наоборот "раздуть" строку:

```{r}
tibble(mn = month.name) |> 
  mutate(mn_new = str_pad(mn, 10))
```

Опять же есть аргумент `side`:

```{r}
tibble(mn = month.name) |> 
  mutate(mn_new = str_pad(mn, 10,  side = "right"))
```

Также можно выбрать, чем "раздувать строку":

```{r}
tibble(mn = month.name) |> 
  mutate(mn_new = str_pad(mn, 10,  pad = "."))
```

Кроме того бывает полезной функций `str_squish()`, которая убирает лишние пробелы в конце и начале строки, а также повторяющиеся пробелы между словами:

```{r}
str_squish("   много     пробелов        не      бывает    ")
```


## Сортировка {#sec-sorting}

Для сортировки существует `str_sort()`:

```{r}
unsorted_latin <- c("I", "♥", "N", "Y")
str_sort(unsorted_latin)
str_sort(unsorted_latin, locale = "lt")
unsorted_cyrillic <- c("я", "i", "ж")
str_sort(unsorted_cyrillic)
str_sort(unsorted_cyrillic, locale = "ru_UA")
```

Список локалей на компьютере можно посмотреть командой `stringi::stri_locale_list()`. Список всех локалей вообще приведен [на этой странице](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes). Еще полезные команды: `stringi::stri_locale_info` и `stringi::stri_locale_set`.

## Поиск подстроки
Можно использовать функцию `str_detect()`:


```{r}
tibble(mn = month.name) |> 
  mutate(has_r = str_detect(mn, "r"))
```

Кроме того, существует функция, которая возвращает индексы, а не значения `TRUE`/`FALSE`:

```{r}
tibble(mn = month.name) |> 
  slice(str_which(month.name, "r"))
```

Также можно посчитать количество вхождений какой-то подстроки:

```{r}
tibble(mn = month.name) |> 
  mutate(has_r = str_count(mn, "r"))
```

## Изменение строк

### Изменение регистра

```{r}
latin <- "tHe QuIcK BrOwN fOx JuMpS OvEr ThE lAzY dOg"
cyrillic <- "лЮбЯ, сЪеШь ЩиПцЫ, — вЗдОхНёТ мЭр, — кАйФ жГуЧ"
str_to_upper(latin)
str_to_lower(cyrillic)
str_to_title(latin)
str_to_sentence(latin)
```

### Выделение подстроки

Подстроку в строке можно выделить двумя способами: по индексам функцией `str_sub()`, и по подстроке функцией `str_png()`.

```{r}
tibble(mn = month.name) |> 
  mutate(mutate = str_sub(mn, start = 1, end = 2))
```


```{r}
tibble(mn = month.name) |> 
  mutate(mutate = str_extract(mn, "r"))
```

По умолчанию функция `str_extract()` возвращает первое вхождение подстроки, соответствующей шаблону. Также существует функция `str_extract_all()`, которая возвращает все вхождения подстрок, соответствующих шаблону в виде объекта типа список.

```{r}
str_extract_all(month.name, "r")
```

### Замена подстроки

Существует функция `str_replace()`, которая позволяет заменить одну подстроку в строке на другую:


```{r}
tibble(mn = month.name) |> 
  mutate(mutate = str_replace(mn, "r", "R"))
```

Как и другие функции, `str_replace()` делает лишь одну замену, чтобы заменить все вхождения подстроки следует использовать функцию `str_replace_all()`:


```{r}
tibble(mn = month.name) |> 
  mutate(mutate = str_replace_all(mn, "r", "R"))
```

### Удаление подстроки

Для удаления подстроки на основе шаблона используется функция `str_remove()` и `str_remove_all()`

```{r}
tibble(month.name) |> 
  mutate(mutate = str_remove(month.name, "r"))
tibble(month.name) |> 
  mutate(mutate = str_remove_all(month.name, "r"))
```

### Транслитерация строк

В пакете `stringi` существует достаточно много методов транслитераций строк, которые можно вывести командой `stri_trans_list()`. Вот пример использования некоторых из них:

```{r}
stri_trans_general("stringi", "latin-cyrillic")
stri_trans_general("сырники", "cyrillic-latin")
stri_trans_general("stringi", "latin-greek")
stri_trans_general("stringi", "latin-armenian")
```

## Регулярные выражения {#sec-regex}

Большинство функций из раздела об операциях над векторами (`str_detect()`, `str_extract()`, `str_remove()` и т. п.) имеют следующую структуру:

- строка, с которой работает функция
- образец (pattern)

Дальше мы будем использовать функцию `str_view()`, которая позволяет показывать выделенное образцом в исходной строке.

```{r}
str_view("Я всегда путаю с и c", "c") # я ищу латинскую c
```

### Экранирование метасимволов
```{r}
a <- "Всем известно, что 4$\\2 + 3$ * 5 = 17$? Да? Ну хорошо (а то я не был уверен). [|}^{|]"
str_view(a, "$")
str_view(a, "\\$")
str_view(a, "\\.")
str_view(a, "\\*")
str_view(a, "\\+")
str_view(a, "\\?")
str_view(a, "\\(")
str_view(a, "\\)")
str_view(a, "\\|")
str_view(a, "\\^")
str_view(a, "\\[")
str_view(a, "\\]")
str_view(a, "\\{")
str_view(a, "\\}")
str_view(a, "\\\\")
```

### Классы знаков

- `\\d` -- цифры. `\\D` -- не цифры.

```{r}
str_view("два 15 42. 42 15. 37 08 5. 20 20 20!", "\\d")
str_view("два 15 42. 42 15. 37 08 5. 20 20 20!", "\\D")
```

- `\\s` -- пробелы. `\\S` -- не пробелы.

```{r}
str_view("два 15 42. 42 15. 37 08 5. 20 20 20!", "\\s")
str_view("два 15 42. 42 15. 37 08 5. 20 20 20!", "\\S")
```

- `\\w` -- не пробелы и не знаки препинания. `\\W` -- пробелы и знаки препинания.

```{r}
str_view("два 15 42. 42 15. 37 08 5. 20 20 20!", "\\w")
str_view("два 15 42. 42 15. 37 08 5. 20 20 20!", "\\W")
```

- произвольная группа символов и обратная к ней

```{r}
str_view("Умей мечтать, не став рабом мечтанья", "[оауиыэёеяю]")
str_view("И мыслить, мысли не обожествив", "[^оауиыэёеяю]")
```

- встроенные группы символов

```{r}
str_view("два 15 42. 42 15. 37 08 5. 20 20 20!", "[0-9]")
str_view("Карл у Клары украл кораллы, а Клара у Карла украла кларнет", "[а-я]")
str_view("Карл у Клары украл кораллы, а Клара у Карла украла кларнет", "[А-Я]")
str_view("Карл у Клары украл кораллы, а Клара у Карла украла кларнет", "[А-я]")
str_view("The quick brown Fox jumps over the lazy Dog", "[a-z]")
str_view("два 15 42. 42 15. 37 08 5. 20 20 20!", "[^0-9]")
```

- выбор из нескольких групп

```{r}
str_view("Карл у Клары украл кораллы, а Клара у Карла украла кларнет", "лар|рал|арл")
```

- произвольный символ

```{r}
str_view("Везет Сенька Саньку с Сонькой на санках. Санки скок, Сеньку с ног, Соньку в лоб, все — в сугроб", "[Сс].н")
```

- знак начала и конца строки

```{r}
str_view("от топота копыт пыль по полю летит.", "^о")
str_view("У ежа — ежата, у ужа — ужата", "жата$")
```

- есть еще другие группы и другие обозначения уже приведенных групп, см. `?regex`

### Квантификация

* `?` --- ноль или один раз

```{r}
str_view("хорошее длинношеее животное", "еее?")
```

* `*` --- ноль и более раз

```{r}
str_view("хорошее длинношеее животное", "ее*")
```

- `+` --- один и более раз

```{r}
str_view("хорошее длинношеее животное", "е+")
```

- `{n}` --- `n` раз

```{r}
str_view("хорошее длинношеее животное", "е{2}")
```

- `{n,}` --- `n` раз и более

```{r}
str_view("хорошее длинношеее животное", "е{1,}")
```

- `{n,m}` --- от `n` до `m`. Отсутствие пробела важно: `{1,2}` --- правильно, `{1,␣2}` --- неправильно.

```{r}
str_view("хорошее длинношеее животное", "е{2,3}")
```

- группировка символов

```{r}
str_view("Пушкиновед, Лермонтовед, Лермонтововед", "(ов)+")
str_view("беловатый, розоватый, розововатый", "(ов)+")
```

- жадный vs. нежадный алоритмы

```{r}
str_view("Пушкиновед, Лермонтовед, Лермонтововед", "в.*ед")
str_view("Пушкиновед, Лермонтовед, Лермонтововед", "в.*?ед")
```

### Позиционная проверка (look arounds)

Позиционная проверка -- выглядит достаточно непоследовательно даже в свете остальных регулярных выражений.

Давайте найдем все *а* **перед** *р*:

```{r}
str_view("Карл у Клары украл кораллы, а Клара у Карла украла кларнет", "а(?=р)")
```

А теперь все *а* **перед** *р* или *л*:

```{r}
str_view("Карл у Клары украл кораллы, а Клара у Карла украла кларнет", "а(?=[рл])")
```

Давайте найдем все а **после** *р*

```{r}
str_view("Карл у Клары украл кораллы, а Клара у Карла украла кларнет", "(?<=р)а")
```

А теперь все *а* **после** *р* или *л*:

```{r}
str_view("Карл у Клары украл кораллы, а Клара у Карла украла кларнет", "(?<=[рл])а")
```

Также у этих выражений есть формы с отрицанием. Давайте найдем все *р* **не перед** *а*:

```{r}
str_view("Карл у Клары украл кораллы, а Клара у Карла украла кларнет", "р(?!а)")
```

А теперь все *р* **не после** *а*:

```{r}
str_view("Карл у Клары украл кораллы, а Клара у Карла украла кларнет", "(?<!а)р")
```

Запомнить с ходу это достаточно сложно, так что подсматривайте сюда:

```{r}
knitr::include_graphics("images/04_01_lookarounds.png")
```


![]("images/04_01_lookarounds.png")
